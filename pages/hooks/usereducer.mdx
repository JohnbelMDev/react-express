---
title: useReducer
---

import useReducer from '../../examples/files/hooks/useReducer.js'
import useStateCompare from '../../examples/files/hooks/useStateCompare.js'

# useReducer

`useReducer` is similar to `useState` since it allows us to control state inside a function component.  
The difference between the two is that `useReducer` allows us to handle multiple states and control complex state changes. 

The `useReducer` hook takes two mandatory arguments: a reducer function and an initial argument. It can also take in an optional third argument called the initializer, which we will briefly introduce later. `useReducer` returns the current state and a dispatch function.  

`const [state, dispatch] = useReducer(reducer, initialState)`

## Reducer

The reducer function is a pure function that takes in the previous state and an action. An action is an arbitrary value we choose that can be any type.  
The reducer returns a new state. 

```
const reducer = (prevState, action) => {
  // do action
  return newState
}
const [state, dispatch] = useReducer(reducer, initialState)
```

## Dispatch

The dispatch function, when called, passes the action to the reducer.

In the Example code below, the initial state is `{color: 'black', pet: 'cat'}`. When we select `dog` from the dropdown, dispatch is called with `{type: 'pet', value: 'dog'}` as its argument. This argument gets passed to the reducer as `action`. Then the reducer follows the switch case logic `case 'pet'` and returns the new state: the current color in state and the newly assigned pet, `{color: 'black', pet: 'dog'}`

*Note: We use a constant to identify the type for the switch case (either PET or COLOR). This is for future maintainability.  
If we were to ever change the type from 'color', we only have to change the string once as opposed to everywhere that COLOR is called.*

<Example code={useReducer}/>

## useState and useReducer

There are situations when one hook is more preferable over the other. 

Examine the code above. If we were to use `useState` in this scenario, what would it look like?

<Example code={useStateCompare}/>

Here, the `useState` version is shorter and simpler, but eventually there will be a trade-off. If we were to continuously add states (for example, adding 'age', 'eye color', 'breed', etc) or even have states that are dependent on the other ('weight', 'weightMeasurement', 'BMI'), the `useState` application would become harder to maintain.

```
  const [color, setColor] = useState("black");
  const [pet, setPet] = useState("cat");
  const [age, setAge] = useState(9);
  const [eyeColor, setEyeColor] = useState('brown')
  const [breed, setBreed] = useState('Maine Coon')
  const [weight, setWeight] = useState(18)
  const [weightMeasurement, setWeightMeasurement] = useState('pounds')
```

versus

```
  const [{color, pet, age, eyeColor, breed, weight, weightMeasurement}, dispatch] = useReducer(reducer, {
    color: 'black', 
    pet: 'cat', 
    age: 9, 
    eyeColor: 'brown', 
    breed: 'Maine Coon', 
    weight: 18, 
    weightMeasurement: 'pounds'
  })
```

Of course, at that time, it may also be a good idea to separate your states into smaller components instead.

Use `useState` for simpler state transition that use JavaScript primitives.

Use `useReducer` when there are different properties that are dependent on one another, JavaScript objects or arrays as state, or complex state business logic.   
The component state will be managed in one place and it would be easier to test and debug.

## The third argument: Initializer

`useReducer` allows us to initialize state in two different ways.  

The first method is setting it in the second argument:

```
const [state, dispatch] = useReducer(reducer, {count: 0})
```

The other method is using the optional third argument. This argument allows us to create the initial state lazily. 
Instead of setting the initial state as the second argument, initial state is now be set to `init(initialArgument)`.  

```
const init = (initialArgument) => {
  {count: initialArgument}
}

let initialArgument = 0
const [state, dispatch] = useReducer(reducer, initialArgument, init)

// state = init(0) = { count: 0 }
```

With this third argument, we can calculate the initial state outside of the `useReducer` function. It is especially useful for resetting the state and handling computationally expensive state initiation.
For more information and examples using this third argument, we recommend checking out the [official React docs](https://reactjs.org/docs/hooks-reference.html#lazy-initialization).