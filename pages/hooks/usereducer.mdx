---
title: useReducer
---

import useReducer from '../../examples/files/hooks/useReducer.js'
import useReducerRefactor from '../../examples/files/hooks/useReducerRefactor.js'
import useReducerLazyInit from '../../examples/files/hooks/useReducerLazyInit.js'

# useReducer

useReducer is similar to useState since it allows us to control state inside a function component.  
The difference between the two is that useReducer allows us to handle multiple states and control complex state changes. 

The useReducer hook takes two mandatory arguments: a reducer function and an initial argument. It can also take in an optional third argument called the initializer, which we will discuss later. useReducer returns the current state and a dispatch function.  

`const [state, dispatch] = useReducer(reducer, initialState)`

## Reducer

The reducer function is a pure function that takes in the previous state and an action. It returns a new state. 

```
const reducer = (prevState, action) => {
  // do action
  return newState
}
const [state, dispatch] = useReducer(reducer, initialState)
```

## Dispatch

The dispatch function, when called, passes the action to the reducer.

In the Example code below, the initial state is `No Pet Selected`. When we click the `cat` radio button, dispatch is called with `{type: 'cat'}` as its argument. This argument gets passed to the reducer as `action`. Then the reducer follows the logic `if (action.type === 'cat')` and returns the new state `You selected cat`

<Example code={useReducer}/>

## useState and useReducer

Here we will highlight some of the differences between useState and useReducer. 

Recall our example in useEffect, there were multiple declarations of useState and several areas where state was changed.  
We can refactor the code with `useReducer` and handle all state changes in one `reducer` function. 

<Example code={useReducerRefactor}/>

There are situations when one hook is the preferable choice over the other. 

For simpler state transition that use JavaScript primitives, it would be ideal to use useState. 

When there are different properties that are dependent on one another, JavaScript objects or arrays as state, or complex state business logic, it is recommended to useReducer because state will be managed in one place and it would provide a more predictable state architecture. 

## The third argument: Initializer

useReducer allows us to initialize state in two different ways.  

The first method is setting it in the second argument:

```
const [state, dispatch] = useReducer(reducer, {count: 0})
```

The other method is using the optional third argument. This argument allows us to create the initial state lazily. 
Instead of setting the initial state as the second argument, initial state is now be set to `init(initialArgument)`.  

```
const init = (initialArgument) => {
  {count: initialArgument}
}

let initialArgument = 0
const [state, dispatch] = useReducer(reducer, initialArgument, init)

// state = init(0) = { count: 0 }
```

With this third argument, we can calculate the initial state outside of the useReducer function. It is especially useful for resetting the state. 

<Example code={useReducerLazyInit}/>